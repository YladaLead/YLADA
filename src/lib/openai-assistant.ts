import OpenAI from 'openai'
import { yladaCache } from './ylada-cache'
import { yladaLearning } from './ylada-learning'
import { AssistantMonitoring, measureLatency } from './assistant-monitoring'

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
})

export interface UserProfile {
  nome?: string
  profissao?: string
  especializacao?: string
  publico_alvo?: string
  objetivo_principal?: string
  tipo_ferramenta?: string
  idioma?: string
  nivel_tecnico?: 'iniciante' | 'intermediario' | 'avancado'
  ultima_ferramenta_criada?: string
  preferencias_ia?: {
    tom?: 'profissional' | 'leve' | 'divertido'
    use_emojis?: boolean
    estilo?: string
  }
}

export interface AssistantResponse {
  message: string
  profile?: Partial<UserProfile>
  nextStep?: number
  complete?: boolean
  toolSuggestion?: {
    name: string
    type: string
    description: string
  }
}

export class YLADAAssistant {
  private chatAssistantId: string
  private creatorAssistantId: string
  private expertAssistantId: string
  private threadId?: string

  constructor() {
    this.chatAssistantId = process.env.OPENAI_ASSISTANT_CHAT_ID || 'asst_default_chat'
    this.creatorAssistantId = process.env.OPENAI_ASSISTANT_CREATOR_ID || 'asst_default_creator'
    this.expertAssistantId = process.env.OPENAI_ASSISTANT_EXPERT_ID || 'asst_default_expert'
  }

  // Criar thread para nova conversa
  async createThread(): Promise<string> {
    try {
      const thread = await openai.beta.threads.create()
      this.threadId = thread.id
      return thread.id
    } catch (error) {
      console.error('Erro ao criar thread:', error)
      throw new Error('Falha ao iniciar conversa com a YLADA Assistant')
    }
  }

  // Enviar mensagem para a assistant
  async sendMessage(message: string, userProfile?: UserProfile): Promise<AssistantResponse> {
    try {
      // Verificar cache primeiro
      const cachedResponse = await yladaCache.getCachedResponse(message, userProfile || {})
      if (cachedResponse) {
        console.log('üéØ Resposta encontrada no cache! Economizando IA...')
        return cachedResponse.assistant_response
      }

      if (!this.threadId) {
        await this.createThread()
      }

      // Determinar qual assistente usar
      const assistantId = this.determineAssistant(message, userProfile)
      const assistantType = this.getAssistantType(assistantId)
      const assistantUsed = this.getAssistantUsed(assistantId)
      const intent = AssistantMonitoring.detectIntent(message, userProfile)
      
      console.log(`ü§ñ Usando ${assistantType} para esta mensagem (intent: ${intent})`)

      // Medir lat√™ncia da opera√ß√£o
      const { result: response, latency } = await measureLatency(async () => {
        // Preparar contexto do usu√°rio
        const contextMessage = this.buildContextMessage(userProfile)
        const fullMessage = contextMessage ? `${contextMessage}\n\n${message}` : message

        // Adicionar mensagem ao thread
        await openai.beta.threads.messages.create(this.threadId!, {
          role: 'user',
          content: fullMessage
        })

        // Verificar se os IDs dos assistentes s√£o v√°lidos antes de tentar usar
        if (assistantId.includes('asst_default_') || !assistantId.startsWith('asst_')) {
          console.warn(`‚ö†Ô∏è ID do assistente inv√°lido: ${assistantId}. Usando fallback local.`)
          throw new Error('Assistente n√£o configurado - usando fallback local')
        }

        // Executar assistant com fallback
        let run
        try {
          run = await openai.beta.threads.runs.create(this.threadId!, {
            assistant_id: assistantId
          })
        } catch (error) {
          console.warn(`‚ö†Ô∏è Erro com ${assistantType}, tentando fallback...`)
          
          // Fallback: se creator falhar, usar expert
          if (assistantId === this.creatorAssistantId && this.expertAssistantId !== 'asst_default_expert') {
            try {
              run = await openai.beta.threads.runs.create(this.threadId!, {
                assistant_id: this.expertAssistantId
              })
              console.log('üîÑ Fallback para Expert executado')
            } catch (expertError) {
              console.warn('‚ö†Ô∏è Expert tamb√©m falhou, usando fallback local')
              throw new Error('Todos os assistentes falharam - usando fallback local')
            }
          } else {
            throw new Error('Assistente n√£o dispon√≠vel - usando fallback local')
          }
        }

        // Aguardar resposta
        let runStatus = await openai.beta.threads.runs.retrieve(this.threadId!, run.id)
        
        while (runStatus.status === 'queued' || runStatus.status === 'in_progress') {
          await new Promise(resolve => setTimeout(resolve, 1000))
          runStatus = await openai.beta.threads.runs.retrieve(this.threadId!, run.id)
        }

        if (runStatus.status === 'completed') {
          // Buscar mensagens do thread
          const messages = await openai.beta.threads.messages.list(this.threadId!)
          const lastMessage = messages.data[0]
          
          if (lastMessage && lastMessage.content[0].type === 'text') {
            const responseText = lastMessage.content[0].text.value
            const parsedResponse = this.parseAssistantResponse(responseText, userProfile)
            
            // Salvar no cache para pr√≥ximas vezes
            await yladaCache.saveCachedResponse(message, userProfile || {}, parsedResponse)
            
            // Salvar dados de aprendizado
            await yladaLearning.saveLearningData(
              message,
              userProfile || {},
              parsedResponse,
              'neutral'
            )
            
            return parsedResponse
          }
        }

        throw new Error('Falha ao obter resposta da assistant')
      })

      // Salvar m√©tricas de monitoramento
      await AssistantMonitoring.saveMetrics({
        assistant_used: assistantUsed,
        tokens_in: AssistantMonitoring.estimateTokens(message),
        tokens_out: AssistantMonitoring.estimateTokens(response.message),
        latency_ms: latency,
        intent,
        escalated: assistantId !== this.determineAssistant(message, userProfile),
        message_length: message.length,
        timestamp: new Date()
      })

      return response

    } catch (error) {
      console.error('Erro ao enviar mensagem:', error)
      
      // Fallback para resposta local se OpenAI falhar
      return this.getFallbackResponse(message, userProfile)
    }
  }

  // Determinar qual assistente usar baseado no contexto
  private determineAssistant(message: string, userProfile?: UserProfile): string {
    const messageLength = message.length
    const messageLower = message.toLowerCase()
    
    // Detectar inten√ß√£o de cria√ß√£o de template
    const isTemplateGeneration = messageLower.includes('criar') || 
                                 messageLower.includes('gerar') || 
                                 messageLower.includes('quiz') || 
                                 messageLower.includes('calculadora') || 
                                 messageLower.includes('checklist') || 
                                 messageLower.includes('planilha') ||
                                 messageLower.includes('diagn√≥stico') ||
                                 messageLower.includes('simulador') ||
                                 messageLower.includes('cat√°logo')
    
    // Detectar casos Enterprise/complexos
    const isEnterpriseCase = messageLength > 1200 || 
                            messageLower.includes('enterprise') ||
                            messageLower.includes('empresa') ||
                            messageLower.includes('contrato') ||
                            messageLower.includes('pol√≠tica') ||
                            messageLower.includes('integra√ß√£o') ||
                            messageLower.includes('b2b') ||
                            messageLower.includes('multi-etapas')
    
    // Detectar escala√ß√£o do chat para creator
    const isEscalationToCreator = userProfile?.objetivo_principal?.toLowerCase().includes('criar') ||
                                  userProfile?.tipo_ferramenta ||
                                  messageLower.includes('ferramenta') ||
                                  messageLower.includes('template')
    
    // L√≥gica de roteamento
    if (isEnterpriseCase) {
      return this.expertAssistantId
    } else if (isTemplateGeneration || isEscalationToCreator) {
      return this.creatorAssistantId
    } else {
      return this.chatAssistantId
    }
  }

  // Obter tipo do assistente usado para m√©tricas
  private getAssistantUsed(assistantId: string): 'chat' | 'creator' | 'expert' {
    if (assistantId === this.chatAssistantId) return 'chat'
    if (assistantId === this.creatorAssistantId) return 'creator'
    if (assistantId === this.expertAssistantId) return 'expert'
    return 'chat' // fallback
  }

  // Obter tipo do assistente para logs
  private getAssistantType(assistantId: string): string {
    if (assistantId === this.chatAssistantId) return 'Chat (GPT-4o mini)'
    if (assistantId === this.creatorAssistantId) return 'Creator (GPT-4o)'
    if (assistantId === this.expertAssistantId) return 'Expert (GPT-4)'
    return 'Unknown'
  }

  // Construir mensagem de contexto baseada no perfil
  private buildContextMessage(profile?: UserProfile): string {
    if (!profile) return ''

    const context = []
    
    if (profile.nome) context.push(`Nome: ${profile.nome}`)
    if (profile.profissao) context.push(`Profiss√£o: ${profile.profissao}`)
    if (profile.especializacao) context.push(`Especializa√ß√£o: ${profile.especializacao}`)
    if (profile.publico_alvo) context.push(`P√∫blico-alvo: ${profile.publico_alvo}`)
    if (profile.objetivo_principal) context.push(`Objetivo: ${profile.objetivo_principal}`)
    if (profile.tipo_ferramenta) context.push(`Tipo de ferramenta: ${profile.tipo_ferramenta}`)
    if (profile.idioma) context.push(`Idioma: ${profile.idioma}`)
    if (profile.preferencias_ia?.tom) context.push(`Tom preferido: ${profile.preferencias_ia.tom}`)

    return context.length > 0 ? `CONTEXTO DO USU√ÅRIO:\n${context.join('\n')}` : ''
  }

  // Parsear resposta da assistant
  private parseAssistantResponse(response: string, currentProfile?: UserProfile): AssistantResponse {
    // Detectar se √© uma resposta de finaliza√ß√£o
    const isComplete = response.includes('gerar') && 
                      (response.includes('link') || response.includes('ferramenta') || response.includes('pronto'))

    // Detectar sugest√£o de ferramenta
    const toolMatch = response.match(/\*\*(.*?)\*\*/)
    const toolSuggestion = toolMatch ? {
      name: toolMatch[1],
      type: 'quiz', // Default, pode ser refinado
      description: response
    } : undefined

    // Detectar pr√≥ximo passo baseado na resposta
    let nextStep: number | undefined
    if (response.includes('foco principal') || response.includes('especializa√ß√£o')) {
      nextStep = 2
    } else if (response.includes('conectar') || response.includes('p√∫blico')) {
      nextStep = 3
    } else if (response.includes('objetivo') || response.includes('meta')) {
      nextStep = 4
    } else if (response.includes('tipo de ferramenta') || response.includes('criar')) {
      nextStep = 5
    } else if (response.includes('tom') || response.includes('estilo')) {
      nextStep = 6
    } else if (response.includes('sugest√µes') || response.includes('op√ß√µes')) {
      nextStep = 7
    }

    return {
      message: response,
      nextStep,
      complete: isComplete,
      toolSuggestion
    }
  }

  // Resposta de fallback se OpenAI falhar
  private getFallbackResponse(message: string, profile?: UserProfile): AssistantResponse {
    const input = message.toLowerCase()
    
    // Detectar profiss√£o e objetivo de uma vez
    let detectedProfession = ''
    let detectedObjective = ''
    
    // Detectar profiss√µes
    if (input.includes('nutricionista') || input.includes('nutri√ß√£o') || input.includes('nutricao')) {
      detectedProfession = 'nutricionista'
    } else if (input.includes('personal trainer') || input.includes('educador f√≠sico') || input.includes('personal')) {
      detectedProfession = 'personal trainer'
    } else if (input.includes('fisioterapeuta') || input.includes('fisio')) {
      detectedProfession = 'fisioterapeuta'
    } else if (input.includes('coach') || input.includes('mentor')) {
      detectedProfession = 'coach'
    } else if (input.includes('esteticista') || input.includes('est√©tica')) {
      detectedProfession = 'esteticista'
    }
    
    // Detectar objetivos
    if (input.includes('atrair') || input.includes('novos clientes') || input.includes('leads')) {
      detectedObjective = 'atrair novos clientes'
    } else if (input.includes('vender') || input.includes('produtos') || input.includes('vendas')) {
      detectedObjective = 'vender produtos/servi√ßos'
    } else if (input.includes('engajar') || input.includes('fidelizar') || input.includes('manter')) {
      detectedObjective = 'engajar clientes atuais'
    } else if (input.includes('educar') || input.includes('conhecimento') || input.includes('autoridade')) {
      detectedObjective = 'educar e gerar valor'
    }
    
    // Resposta baseada no que foi detectado
    if (detectedProfession && detectedObjective) {
      return {
        message: `Perfeito! Entendi que voc√™ √© **${detectedProfession}** e quer **${detectedObjective}**.

üéØ **Aqui est√£o as melhores ferramentas para voc√™:**

${detectedProfession === 'nutricionista' ? `
üß© **Quiz "Descubra seu Perfil Metab√≥lico"** - ideal para atrair leads qualificados
üßÆ **Calculadora "Seu D√©ficit Cal√≥rico Ideal"** - excelente para engajamento
üìä **Diagn√≥stico "Avalie sua Rela√ß√£o com a Comida"** - perfeito para convers√£o
` : detectedProfession === 'personal trainer' ? `
üèãÔ∏è **Desafio "7 Dias de Foco Total"** - ideal para engajamento
üìà **Ranking "Seu N√≠vel de Fitness"** - excelente para gamifica√ß√£o
üßÆ **Calculadora "Seu Treino Ideal"** - perfeito para personaliza√ß√£o
` : detectedProfession === 'coach' ? `
üß† **Diagn√≥stico "Mapa da Clareza Mental"** - ideal para autoconhecimento
üìã **Checklist "Transforma√ß√£o em 30 Dias"** - excelente para engajamento
üéØ **Quiz "Seu Perfil de Lideran√ßa"** - perfeito para desenvolvimento
` : `
üß© **Quiz Personalizado** - ideal para ${detectedObjective}
üìä **Diagn√≥stico Especializado** - excelente para engajamento
üßÆ **Calculadora Inteligente** - perfeito para convers√£o
`}

**Qual dessas ferramentas voc√™ gostaria de criar primeiro?** üöÄ`,
        profile: { 
          profissao: detectedProfession, 
          objetivo_principal: detectedObjective 
        },
        nextStep: 5,
        complete: true
      }
    } else if (detectedProfession) {
      return {
        message: `√ìtimo! Vejo que voc√™ √© **${detectedProfession}**.

Agora me conte: **qual √© seu objetivo principal** com essa ferramenta?

‚Ä¢ üéØ **Atrair novos clientes** - pessoas interessadas em seus servi√ßos
‚Ä¢ ü§ù **Engajar clientes atuais** - manter relacionamento e fidelidade  
‚Ä¢ üåü **Gerar indica√ß√µes** - transformar clientes em promotores
‚Ä¢ üõí **Vender produtos/servi√ßos** - aumentar vendas e convers√£o
‚Ä¢ üìò **Educar e gerar valor** - mostrar autoridade e conhecimento

**Qual desses objetivos mais se alinha com o que voc√™ quer criar hoje?**`,
        profile: { profissao: detectedProfession },
        nextStep: 3
      }
    } else if (detectedObjective) {
      return {
        message: `Perfeito! Entendi que voc√™ quer **${detectedObjective}**.

Agora me conte: **qual √© sua profiss√£o ou √°rea de atua√ß√£o?**

‚Ä¢ ü•ó **Nutricionista** - especialista em alimenta√ß√£o e sa√∫de
‚Ä¢ üèãÔ∏è **Personal Trainer** - especialista em exerc√≠cios e fitness
‚Ä¢ ü©∫ **Fisioterapeuta** - especialista em reabilita√ß√£o e movimento
‚Ä¢ üß† **Coach** - especialista em desenvolvimento pessoal
‚Ä¢ üíÜ **Esteticista** - especialista em beleza e bem-estar
‚Ä¢ ‚ú® **Outro** - me conte sua profiss√£o espec√≠fica

**Qual √© sua √°rea de atua√ß√£o?**`,
        profile: { objetivo_principal: detectedObjective },
        nextStep: 2
      }
    }

    // Resposta gen√©rica
    return {
      message: `Entendi! Para criar a ferramenta perfeita para voc√™, preciso saber:

**1. Qual √© sua profiss√£o?** (ex: nutricionista, personal trainer, coach...)
**2. Qual seu objetivo principal?** (atrair clientes, vender produtos, gerar leads...)

Pode responder tudo de uma vez! Assim eu crio algo personalizado para suas necessidades espec√≠ficas. üéØ`,
      nextStep: 1
    }
  }

  // Gerar sugest√µes de ferramentas baseadas no perfil
  generateToolSuggestions(profile: UserProfile): string {
    const { profissao, especializacao, objetivo_principal, tipo_ferramenta } = profile
    
    let suggestions = `üéØ Sugest√µes personalizadas para voc√™:\n\n`
    
    if (profissao?.toLowerCase().includes('nutricionista')) {
      if (especializacao?.toLowerCase().includes('emagrecimento')) {
        suggestions += `‚úÖ **Quiz "Descubra seu Perfil Metab√≥lico"** ‚Äî ideal para ${objetivo_principal}\n`
        suggestions += `‚úÖ **Calculadora "Seu D√©ficit Cal√≥rico Ideal"** ‚Äî excelente para gerar leads qualificados\n`
      } else if (especializacao?.toLowerCase().includes('esportiva')) {
        suggestions += `‚úÖ **Quiz "Seu Perfil de Performance"** ‚Äî ideal para atletas\n`
        suggestions += `‚úÖ **Calculadora "Suas Necessidades Proteicas"** ‚Äî excelente para convers√£o\n`
      } else {
        suggestions += `‚úÖ **Quiz "Descubra seu Perfil Nutricional"** ‚Äî ideal para ${objetivo_principal}\n`
        suggestions += `‚úÖ **Calculadora "Seu √çndice de Energia"** ‚Äî excelente para gerar valor\n`
      }
    } else if (profissao?.toLowerCase().includes('esteticista')) {
      suggestions += `‚úÖ **Simulador "Monte seu Tratamento Ideal"** ‚Äî ideal para ${objetivo_principal}\n`
      suggestions += `‚úÖ **Cat√°logo "Transforme sua Pele em 30 Dias"** ‚Äî excelente para convers√£o\n`
    } else if (profissao?.toLowerCase().includes('personal trainer')) {
      suggestions += `‚úÖ **Desafio "7 Dias de Foco Total"** ‚Äî ideal para engajamento\n`
      suggestions += `‚úÖ **Ranking "Seu N√≠vel de Fitness"** ‚Äî excelente para gamifica√ß√£o\n`
    } else if (profissao?.toLowerCase().includes('coach')) {
      suggestions += `‚úÖ **Diagn√≥stico "Mapa da Clareza Mental"** ‚Äî ideal para ${objetivo_principal}\n`
      suggestions += `‚úÖ **E-book "Guia de Transforma√ß√£o"** ‚Äî excelente para gerar valor\n`
    } else {
      suggestions += `‚úÖ **${tipo_ferramenta || 'Quiz'} "${especializacao || 'Personalizado'}"** ‚Äî ideal para ${objetivo_principal}\n`
      suggestions += `‚úÖ **Checklist "Guia de Sucesso"** ‚Äî excelente para gerar valor\n`
    }
    
    suggestions += `\nQuer que eu gere o link e a capa visual da primeira? üé®`
    
    return suggestions
  }

  // Gerar nome da ferramenta baseado no perfil
  generateToolName(profile: UserProfile): string {
    const { profissao, especializacao, tipo_ferramenta } = profile
    
    if (profissao?.toLowerCase().includes('nutricionista')) {
      if (especializacao?.toLowerCase().includes('emagrecimento')) {
        return 'Descubra seu Perfil Metab√≥lico'
      } else if (especializacao?.toLowerCase().includes('esportiva')) {
        return 'Seu Perfil de Performance'
      } else {
        return 'Descubra seu Perfil Nutricional'
      }
    } else if (profissao?.toLowerCase().includes('esteticista')) {
      return 'Monte seu Tratamento Ideal'
    } else if (profissao?.toLowerCase().includes('personal trainer')) {
      return 'Desafio dos 7 Dias de Foco'
    } else if (profissao?.toLowerCase().includes('coach')) {
      return 'Mapa da Clareza Mental'
    } else {
      return `${tipo_ferramenta || 'Ferramenta'} de ${especializacao || 'Sucesso'}`
    }
  }
}

// Inst√¢ncia singleton
export const yladaAssistant = new YLADAAssistant()
